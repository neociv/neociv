# ![NEOCIV](https://raw.githubusercontent.com/neociv/neociv/master/logo.svg)

# neociv-civil

Lua based API for interacting with the state of a Neociv game.

## (CIV)(I)n(L)ua *or* (CIV)(I)n(L)isp

Supports both Lua and Lisp (via [Fennel](https://fennel-lang.org)) syntax. Syntax is chosen by file extension (.lua or .fnl / .cvl) - fennel will be transpiled at runtime and does *not* require precompilation (unless you want to). Examples will be shown with both syntaxes. Other languages that compile to Lua will also work provided you load the compiled output, for example [Teal](https://github.com/teal-language/tl).

## cvl

The top-level API exists entirely in the `cvl` global. It does *not* require importing into your code and is always available.

### Events

Events are things that have happened in Neociv.

To listen for events the `on` function is used. Event listeners are processed in the order they are added.

```lua
cvl.on("example", handler)
```

```fennel
(cvl.on :example handler)
```

Handler functions receive two parameters, the first is any event data and the second is the event type. Event handlers can be written without making use of any parameters or just the data parameter (most common use case presumably).

```lua
function handler(d,t)
    return d
end
```

```fennel
(fn handler [d t] d)
```

One of the more interesting usages of the handler functions though is that you can *modify* the data given to the next handler. The `data` entry in the event handler table is *immutable* and thus must be returned. What value Neociv *actually* uses will be the result of these series of event handlers.

Not returning or returning `nil` will behave identically to returning an unaltered data table.

To make modifying an immutable table easier the `cvl.mod` function allows for cherrypicking values to modify while still returning the whole table. Table keys provided are actually paths so `"path.to.value"` is equivalent to addressing `path.to.value` directly.

For example, let's create an event handler to increase all currency gains by 10%.

```lua
cvl.on("currency.generated", function (d)
    return cvl.mod({ value = d.value + d.value * 0.1 })
end)
```

```fennel
(cvl.on :currency.generated (fn [d]
    (cvl.mod { :value (+ d.value (* d.value 0.1)) })))
```

An additional options table can also be provided with the following schema as the final argument.

```typescript
{
    /// The event handler will respond this number of times before removing itself, defaults to math.huge (infinity)
    count?: number;
    /// Preserve the original data and do not allow for modification, defaults to false
    preserve?: boolean;
}
```

```lua
cvl.on("example", handler, { count = 42 })
```

```fennel
(cvl.on :example handler { :count 42 })
```

For the sake of convenience there is also a `once` function that accepts all other options but will force the `count` value to `1`

```lua
cvl.once("example", handler)
```

```fennel
(cvl.once :example handler)
```

To dispatch an event the `dispatch` function is used. Optional data can also be passed to listeners.

```lua
cvl.dispatch("example")
cvl.dispatch("example", { "foo" = "bar" })
```

```fennel
(cvl.dispatch :example)
(cvl.dispatch :example { :foo :bar })
```

The following table of events should be considered "reliable" in that they are generated by Neociv. It is *very* important to note that you can dispatch and listen for *anything* - there is no validation done whatsoever. Don't be a gronk.

| Event | Data | Description |
| ----- | ---- | ----------- |

### Actions

Actions are operations that are performed on the state that can be made from Lua.

## Third Party Libraries

The runtime API includes several compiled-in Lua modules, some exposed / used via the `cvl` global but all are importable into your own code.

[inspect.lua](https://github.com/kikito/inspect.lua)
[lunajson](https://github.com/grafi-tt/lunajson)