# ![NEOCIV](https://raw.githubusercontent.com/neociv/neociv/master/logo.svg)

# neociv-civil

Lua based API for interacting with the state of a Neociv game.

## (CIV)(I)n(L)ua *or* (CIV)(I)n(L)isp

Supports both Lua and Lisp (via [Fennel](https://fennel-lang.org)) syntax. Syntax is chosen by file extension (.lua or .fnl / .cvl) - fennel will be transpiled at runtime and does *not* require precompilation (unless you want to). Examples will be shown with both syntaxes. Other languages that compile to Lua will also work provided you load the compiled output, for example [Teal](https://github.com/teal-language/tl).

## cvl

The top-level API exists entirely in the `cvl` global. It does *not* require importing into your code and is always available.

### Events

Events are things that have happened in Neociv.

To listen for events the `on` function is used. Event listeners are processed in the order they are added.

```lua
cvl.on("example", handler)
```

```fennel
(cvl.on :example handler)
```

Handler functions receive a table with the following structure:

```typescript
{
    type: string;
    data?: any;
}
```

One of the more interesting usages of the handler functions though is that you can *modify* the data given to the next handler. The `data` entry in the event handler table is *mutable* and does not require returning. What value Neociv *actually* uses will be the result of these series of event handlers.

For example, let's create an event handler to increase all currency gains by 10%.

```lua
cvl.on("currency.generated", function (evt)
    evt.data.value = evt.data.value + (evt.data.value * 0.1)
end)
```

```fennel
(cvl.on :currency.generated (fn [evt]
        (set evt.data.value (+ evt.data.value (* evt.data.value 0.1))))
```

An additional options table can also be provided with the following schema as the final argument.

```typescript
{
    /// The event handler will respond this number of times before removing itself, defaults to math.huge (infinity)
    count?: number;
    /// Preserve the original data and do not allow for modification, defaults to false
    preserve?: boolean;
}
```

```lua
cvl.on("example", handler, { count = 42 })
```

```fennel
(cvl.on :example handler { :count 42 })
```

For the sake of convenience there is also a `once` function that accepts all other options but will force the `count` value to `1`

```lua
cvl.once("example", handler)
```

```fennel
(cvl.once :example handler)
```

To dispatch an event the `dispatch` function is used. Optional data can also be passed to listeners.

```lua
cvl.dispatch("example")
cvl.dispatch("example", { "foo" = "bar" })
```

```fennel
(cvl.dispatch :example)
(cvl.dispatch :example { :foo :bar })
```

The following table of events should be considered "reliable" in that they are generated by Neociv. It is *very* important to note that you can dispatch and listen for *anything* - there is no validation done whatsoever. Don't be a gronk.

| Event | Data | Description |
| ----- | ---- | ----------- |

### Actions

Actions are operations that are performed on the state that can be made from Lua.

## Third Party Libraries

The runtime API includes several compiled-in Lua modules, some exposed / used via the `cvl` global but all are importable into your own code.

[inspect.lua](https://github.com/kikito/inspect.lua)
